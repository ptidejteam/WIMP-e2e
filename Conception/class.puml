
@startuml

package "payload" {
 
  class PayloadService {
    - db: MongoClient
    - wsPort: int
    - usedConnection: Connection
    + TryDatabaseConnect(): void
    + getHistory(): List<PayloadHistory>
    + getSpecificHistory(userName: String, date: String): PayloadHistory
    + analysePayload(jsonContent: String): boolean
    + savePayload(payloadHistory: PayloadHistory): boolean
    + establishSender(protocol: String, method: String): boolean
    + execPayload(jsonFile: JSON): boolean
  }

  class PayloadHistory {
    - userName : String  
    - date : String 
    - uniqueID : String 
    - receivedOn : Date 
    - payload :  String 
    - payloadStatus : String 
    - payloadOutcome : String 
    - triggeringEvent : String 
  }

  interface Connection {
    + disconnect(): void
  }

  class WebSocketConnexion extends Connection {
    + WebSocketConnexion(wsPort: int)
    + disconnect(): void
  }

  class CoAPConnexion extends Connection {
    + CoAPConnexion(wsPort: int)
    + disconnect(): void
  }

  class HTTPConnexion extends Connection {
    + HTTPConnexion(wsPort: int)
    + disconnect(): void
  }

  class MQTTConnexion extends Connection {
    + MQTTConnexion(wsPort: int)
    + disconnect(): void
  }
}

package "executetest" {
  class TestResultService {
    - db: MongoClient
    - wsPort: int
    - usedReceiver: Receiver
    + addTestResult(testResult: TestResult): boolean
    + getTestResults(date: Date): List<TestResult>
    + getAllTestResults(): List<TestResult>
    + updatePreviousJSON(previousJSON: String): boolean
    + establishReceiver(protocol: String, method: String): boolean
    + addExpectations(expectations: List<String>, protocol: String, method: String): boolean
  }

  class TestResult {
    + command : String
    + endPoint : String
    + status : String
    + message : String
    + date : Date
  }

  interface Receiver {
    + disconnect(): void
    + addExpectation(expectation: String): void
  }

  class WebSocketReceiver extends Receiver {
    + WebSocketReceiver(wsPort: int)
    + disconnect(): void
  }

  class CoAPReceiver extends Receiver {
    + CoAPReceiver(wsPort: int)
    + disconnect(): void
  }

  class HTTPReceiver extends Receiver {
    + HTTPReceiver(wsPort: int)
    + disconnect(): void
  }

  class MQTTReceiver extends Receiver {
    + MQTTReceiver(wsPort: int)
    + disconnect(): void
  }
}

package "authservice" {
  class AuthService {
    - db: MongoClient
    + createUser(userName: String, userEmail: String, userPassword: String, userAge: int): boolean
    + loginUser(userEmail: String, userPassword: String): String
  }

  class User {
    - userName : String
    - userEmail : String
    - userPassword : String
  }

  class TokenService {
    + generateJWTToken(userEmail: String): String
  }

  class BcryptService {
    + hashPassword(password: String): String
    + comparePassword(password: String, hashedPassword: String): boolean
  }
}

package "serviceregistry" {
  class ServiceRegistry {
    + services: List<Service>
    + requestList: Map<String, int>
    + rateLimit: int
    + interval: int
    + rateLimitAndTimeout(req, res, next): void
    + createProxies(): void
  }

  class Service {
    - route : String
    - target : String
  }

  class ProxyMiddleware {
    + createProxyMiddleware(options: Map<String, String>): void
  }

  class RateLimiter {
    + checkRateLimit(ip: String): boolean
    + resetRateLimit(): void
  }
}

PayloadService "1" -- "0..*" PayloadHistory : manages
PayloadService "1" -- "1" Connection : uses


TestResultService "1" -- "0..*" TestResult : manages
TestResultService "1" -- "1" Receiver : uses


AuthService "1" -- "0..*" User : manages
AuthService "1" -- "1" TokenService : uses
AuthService "1" -- "1" BcryptService : uses

ServiceRegistry "1" -- "0..*" Service : manages
ServiceRegistry "1" -- "1" ProxyMiddleware : uses
ServiceRegistry "1" -- "1" RateLimiter : uses

authservice -up- serviceregistry : registers
payload -left- serviceregistry : registers
executetest -up- serviceregistry : registers
@enduml

@startuml
skinparam linetype ortho

package "authservice" {
  class AuthService {
    - db: MongoClient
    + createUser(userName: String, userEmail: String, userPassword: String, userAge: int): boolean
    + loginUser(userEmail: String, userPassword: String): String
  }

  class User {
    - userName: String
    - userEmail: String
    - userPassword: String
  }

  class TokenService {
    + generateJWTToken(userEmail: String): String
  }

  class BcryptService {
    + hashPassword(password: String): String
    + comparePassword(password: String, hashedPassword: String): boolean
  }
}

package "serviceregistry" {
  class ServiceRegistry {
    + services: List<Service>
    + requestList: Map<String, int>
    + rateLimit: int
    + interval: int
    + rateLimitAndTimeout(req, res, next): void
    + createProxies(): void
  }

  class Service {
    - route: String
    - target: String
  }

  class ProxyMiddleware {
    + createProxyMiddleware(options: Map<String, String>): void
  }

  class RateLimiter {
    + checkRateLimit(ip: String): boolean
    + resetRateLimit(): void
  }
}

package "payload" {
  class PayloadService {
    - db: MongoClient
    - wsPort: int
    - usedConnection: Connection
    + TryDatabaseConnect(): void
    + getHistory(): List<PayloadHistory>
    + getSpecificHistory(userName: String, date: String): PayloadHistory
    + analysePayload(jsonContent: String): boolean
    + savePayload(payloadHistory: PayloadHistory): boolean
    + establishSender(protocol: String, method: String): boolean
    + execPayload(jsonFile: JSON): boolean
  }

  class PayloadHistory {
    - userName: String  
    - date: String 
    - uniqueID: String 
    - receivedOn: Date 
    - payload: String 
    - payloadStatus: String 
    - payloadOutcome: String 
    - triggeringEvent: String 
  }

  interface Connection {
    + disconnect(): void
  }

  class WebSocketConnexion extends Connection {
    + WebSocketConnexion(wsPort: int)
    + disconnect(): void
  }

  class CoAPConnexion extends Connection {
    + CoAPConnexion(wsPort: int)
    + disconnect(): void
  }

  class HTTPConnexion extends Connection {
    + HTTPConnexion(wsPort: int)
    + disconnect(): void
  }

  class MQTTConnexion extends Connection {
    + MQTTConnexion(wsPort: int)
    + disconnect(): void
  }
}

package "executetest" {
  class TestResultService {
    - db: MongoClient
    - wsPort: int
    - usedReceiver: Receiver
    + addTestResult(testResult: TestResult): boolean
    + getTestResults(date: Date): List<TestResult>
    + getAllTestResults(): List<TestResult>
    + updatePreviousJSON(previousJSON: String): boolean
    + establishReceiver(protocol: String, method: String): boolean
    + addExpectations(expectations: List<String>, protocol: String, method: String): boolean
  }

  class TestResult {
    + command: String
    + endPoint: String
    + status: String
    + message: String
    + date: Date
  }

  interface Receiver {
    + disconnect(): void
    + addExpectation(expectation: String): void
  }

  class WebSocketReceiver extends Receiver {
    + WebSocketReceiver(wsPort: int)
    + disconnect(): void
  }

  class CoAPReceiver extends Receiver {
    + CoAPReceiver(wsPort: int)
    + disconnect(): void
  }

  class HTTPReceiver extends Receiver {
    + HTTPReceiver(wsPort: int)
    + disconnect(): void
  }

  class MQTTReceiver extends Receiver {
    + MQTTReceiver(wsPort: int)
    + disconnect(): void
  }
}

PayloadService "1" -- "0..*" PayloadHistory: manages
PayloadService "1" -- "1" Connection: uses


TestResultService "1" -- "0..*" TestResult: manages
TestResultService "1" -- "1" Receiver: uses


AuthService "1" -- "0..*" User: manages
AuthService "1" -- "1" TokenService: uses
AuthService "1" -- "1" BcryptService: uses

ServiceRegistry "1" -- "0..*" Service: manages
ServiceRegistry "1" -- "1" ProxyMiddleware: uses
ServiceRegistry "1" -- "1" RateLimiter: uses

authservice -down-> serviceregistry: registers
payload -left-> serviceregistry: registers
executetest -up-> serviceregistry: registers
@enduml

@startuml
@startuml
package "serviceregistry" {
  ' Package 2
  note as N2
  Ce package gère l'enregistrement des services,
   la création de proxys et 
   l'application des limites de débit
  end note

  class ServiceRegistry {
    + services: List<Service>
    + requestList: Map<String, int>
    + rateLimit: int
    + interval: int
    + rateLimitAndTimeout(req, res, next): void
    + createProxies(): void
  }

  class Service {
    - route: String
    - target: String
  }

  class ProxyMiddleware {
    + createProxyMiddleware(options: Map<String, 
    String>): void
  }

  class RateLimiter {
    + checkRateLimit(ip: String): boolean
    + resetRateLimit(): void
  }

  ServiceRegistry "1" -- "0..*" Service: manages
  ServiceRegistry "1" -- "1" ProxyMiddleware: uses
  ServiceRegistry "1" -- "1" RateLimiter: uses

  N2 .. ServiceRegistry
}
@enduml

package "serviceregistry" {
  ' Package 2
  note as N2
  Ce package gère l'enregistrement des services, la création de proxys et l'application des limites de débit.
  end note

  class ServiceRegistry {
    + services: List<Service>
    + requestList: Map<String, int>
    + rateLimit: int
    + interval: int
    + rateLimitAndTimeout(req, res, next): void
    + createProxies(): void
  }

  class Service {
    - route: String
    - target: String
  }

  class ProxyMiddleware {
    + createProxyMiddleware(options: Map<String, String>): void
  }

  class RateLimiter {
    + checkRateLimit(ip: String): boolean
    + resetRateLimit(): void
  }

  ServiceRegistry "1" -- "0..*" Service: manages
  ServiceRegistry "1" -- "1" ProxyMiddleware: uses
  ServiceRegistry "1" -- "1" RateLimiter: uses

  N2 .. ServiceRegistry
}
@enduml
